# Zedi データ構造仕様（新設計）

**作成日:** 2026-02-08  
**ステータス:** 検討用ドラフト  
**目的:** ローカルファースト・リアルタイム編集・共有を満たす新しい Zedi のデータ構造と同期方針を定義する。

---

## 1. 方針の整理

### 1.1 前提

| 項目 | 方針 |
|------|------|
| **テーブル名** | 現行の **pages** / **notes** を残す（documents 等へのリネームは行わない）。 |
| **ID** | すべて **UUID** に統一する（移行時に Turso の nanoid 等から変換）。 |
| **ローカルファースト** | データをローカルに保持し、クラウドと同期しなくても一覧・表示できるようにする。 |
| **リアルタイム編集** | 同一ページの編集をリアルタイムで反映する（Y.js + Hocuspocus）。 |
| **共有モデル** | 「共有される単位はノート（notes）」で、ノートにページが紐づく。自分だけのページと、ノート経由で見るページを明確に分ける。 |

### 1.2 データの種類の整理

| 種類 | 説明 | 例 |
|------|------|-----|
| **自分のみのページ** | 自分が所有者のページ。アプリで新規作成したページ、または共有ノート内のページを「コピーして自分のページにする」もの。 | 原稿用に作成したページ、他ユーザーから共有されたノートのページをコピーしたもの |
| **共有されるページ** | すべて **notes に紐づいており**、notes 単位で他ユーザーに共有される。ノートのメンバーは、そのノートに含まれるページを閲覧・編集（権限による）。 | ノート A に含まれるページは、ノート A のオーナー／メンバーがアクセス可能 |

つまり「ページの共有」は常に **ノート経由** であり、単体のページを直接「このユーザーに共有」する機能は持たない（現行と同じ）。

---

## 2. エンティティ定義

### 2.1 users（ユーザー）

Cognito と対応づけるためのユーザー情報。認証後、アプリ内で一意にユーザーを指すのに使う。

| カラム | 型 | 説明 |
|--------|-----|------|
| id | UUID | 主キー。アプリ内でユーザーを一意に指す。 |
| cognito_sub | TEXT | Cognito の sub（UNIQUE）。認証プロバイダと紐づけ。 |
| email | TEXT | メールアドレス（UNIQUE）。招待・メンバー識別に利用。 |
| display_name | TEXT | 表示名。 |
| avatar_url | TEXT | アバター URL。 |
| created_at | TIMESTAMPTZ | 作成日時。 |
| updated_at | TIMESTAMPTZ | 更新日時。 |

- 初回サインイン時に users に upsert する想定。
- pages / notes の owner_id 等は **users.id (UUID)** を参照する。

---

### 2.2 pages（ページ）

「情報の最小単位」。1 ページ = 1 つの編集対象（Tiptap + Y.Doc）。

| カラム | 型 | 説明 |
|--------|-----|------|
| id | UUID | 主キー。 |
| owner_id | UUID NOT NULL | 所有者。users.id を参照。常に「このページを所有するユーザー」を表す。 |
| source_page_id | UUID NULL | **コピー元ページ**。このページが「共有ノートのページをコピーして自分のページにした」場合、元ページの id を格納。原稿で自動作成したページ等は NULL。 |
| title | TEXT | タイトル。 |
| content_preview | TEXT | 一覧用プレビュー（Y.Doc から派生または同期で更新）。 |
| thumbnail_url | TEXT | サムネイル URL。 |
| source_url | TEXT | 元 URL（クリップ等）。 |
| created_at | TIMESTAMPTZ | 作成日時。 |
| updated_at | TIMESTAMPTZ | 更新日時。 |
| is_deleted | BOOLEAN | 論理削除フラグ。 |

**コンテンツ本体（本文）について**

- 本文は **Y.Doc（CRDT）** で保持し、リアルタイム編集とオフライン対応の単位とする。
- **pages テーブルには本文を格納しない**。本文は次のように扱う：
  - **クライアント:** Y.Doc を page_id をキーに IndexedDB（y-indexeddb）で保持 → クラウド同期なしでも表示可能。
  - **サーバー:** Hocuspocus のルーム = page_id。接続時に Y.Doc を同期。永続化する場合は別テーブル（例: page_contents）に ydoc_state を保存し、再起動・新インスタンス時に復元する。

オプションで、検索・一覧用に「本文のテキスト」を DB に持つ場合は、Y.Doc から定期的に導出した content_text を pages に持たせる、または page_contents に持たせる形にできる（全文検索用）。本仕様では「content_preview のみ pages に持つ」最小形を前提とする。

---

### 2.3 notes（ノート）

共有のコンテナ。**ノート単位**で他ユーザーに共有する。

| カラム | 型 | 説明 |
|--------|-----|------|
| id | UUID | 主キー。 |
| owner_id | UUID NOT NULL | ノートの所有者。users.id を参照。 |
| title | TEXT | ノートのタイトル。 |
| visibility | TEXT | 'private' \| 'public' \| 'unlisted' \| 'restricted'（現行と同様）。 |
| created_at | TIMESTAMPTZ | 作成日時。 |
| updated_at | TIMESTAMPTZ | 更新日時。 |
| is_deleted | BOOLEAN | 論理削除フラグ。 |

---

### 2.4 note_pages（ノートとページの紐付け）

どのページがどのノートに含まれるかを表す。1 ページは複数ノートに含まれうる（現行と同様の多対多）。

| カラム | 型 | 説明 |
|--------|-----|------|
| note_id | UUID | ノート。notes.id を参照。 |
| page_id | UUID | ページ。pages.id を参照。 |
| added_by_user_id | UUID | 追加したユーザー。users.id を参照。 |
| sort_order | INTEGER | ノート内での表示順（任意。0-based など）。 |
| created_at | TIMESTAMPTZ | 追加日時。 |
| updated_at | TIMESTAMPTZ | 更新日時。 |
| is_deleted | BOOLEAN | 論理削除フラグ。 |

PRIMARY KEY: (note_id, page_id)

- **共有されるページ** = note_pages にレコードがあり、その note のメンバーまたは visibility により他ユーザーがアクセスできるページ。
- ページの「所有者」は pages.owner_id のまま。ノートに含めるだけでは所有者は変わらない。

---

### 2.5 note_members（ノートメンバー）

ノートを誰に共有しているか。招待は **メール** で行う想定（現行同様）。users とメールで対応づける。

| カラム | 型 | 説明 |
|--------|-----|------|
| note_id | UUID | ノート。notes.id を参照。 |
| member_email | TEXT | 招待されたメールアドレス。 |
| role | TEXT | 'viewer' \| 'editor'。 |
| invited_by_user_id | UUID | 招待したユーザー。users.id を参照。 |
| created_at | TIMESTAMPTZ | 招待日時。 |
| updated_at | TIMESTAMPTZ | 更新日時。 |
| is_deleted | BOOLEAN | 論理削除フラグ。 |

PRIMARY KEY: (note_id, member_email)

---

### 2.6 links（ページ間リンク）

双方向リンクのグラフ構造。現行と同様。

| カラム | 型 | 説明 |
|--------|-----|------|
| source_id | UUID | リンク元ページ。pages.id を参照。 |
| target_id | UUID | リンク先ページ。pages.id を参照。 |
| created_at | TIMESTAMPTZ | 作成日時。 |

PRIMARY KEY: (source_id, target_id)

---

### 2.7 ghost_links（未作成リンク）

「まだページが存在しない」リンクテキストのトラッキング。加えて、**共有ノートからコピーしたページ**内で「元のノート内の他ページ」へのリンクをゴーストリンクにした場合、その元参照先を保持するための拡張カラムを持つ。

| カラム | 型 | 説明 |
|--------|-----|------|
| link_text | TEXT | リンクテキスト。 |
| source_page_id | UUID | リンクが書かれているページ。pages.id を参照。 |
| created_at | TIMESTAMPTZ | 作成日時。 |
| original_target_page_id | UUID NULL | **共有ノート由来のゴーストのみ。** 元のリンク先ページの id。通常のゴースト（手書きの未解決リンク）は NULL。 |
| original_note_id | UUID NULL | **共有ノート由来のゴーストのみ。** 元のリンク先が属していたノートの id。通常のゴーストは NULL。 |

PRIMARY KEY: (link_text, source_page_id)

- `original_target_page_id` と `original_note_id` は **両方 NULL**（通常のゴースト）か **両方 NOT NULL**（共有ノートからコピーしたページ内のリンクをゴースト化したもの）のいずれかとする。
- 両方が非 NULL のとき、クリック時に「自分のオリジナルページとして作成」か「元の共有ノートのページをコピー」を選択する UX（§3.4）で利用する。

---

## 3. アクセスと「自分のページ / 共有のページ」の整理

### 3.1 ページの見え方

| 観点 | 条件 | 説明 |
|------|------|------|
| **自分のみのページ** | pages.owner_id = 自分 | 自分が所有者のページ。一覧は「自分のページ」として表示。編集・削除・ノートへの追加が可能。 |
| **共有されて見えるページ** | ある note の note_pages に含まれ、かつその note に対して自分がオーナーまたは note_members に含まれる | ノート単位で共有されているため、「ノート一覧」で見えるノートに含まれるページとして表示。権限に応じて閲覧・編集。 |
| **コピーして自分のページ** | 新規 pages を生成し、owner_id = 自分、source_page_id = 元ページの id、本文をコピー（Y.Doc を複製または再構築） | 共有ノート内のページを「自分のページとしてコピー」したもの。以降は通常の「自分のページ」として扱う。 |

### 3.2 ノートの見え方（現行と同様）

- **オーナー:** ノートの作成・編集・削除・メンバー管理・ノート内ページの追加・削除が可能。
- **メンバー (editor):** ノート内ページの追加・編集が可能（ノートの設定変更はオーナーのみの想定）。
- **メンバー (viewer):** ノート内ページの閲覧のみ。
- **visibility:** public / unlisted / restricted のとき、メンバーでなくてもリンク等でアクセスできる場合は「閲覧可能」とする（現行の canView ロジックに準拠）。

### 3.3 共有ノートからコピーしたページ内のリンクの扱い

共有ノートから「自分のページとしてコピー」したページには、**同じノート内の他ページへのリンク**が含まれている場合がある。コピー後は「自分のページ」として `/page/[id]` で開くため、それらのリンク先（他ユーザーが所有するページや、同じノート内の別ページ）をどう解釈するかを決める必要がある。

#### 選択肢

| 方針 | 概要 | メリット | デメリット |
|------|------|----------|------------|
| **A. リンクをそのまま維持** | コピー後もリンク先は元の page_id のまま。クリック時、そのページにアクセス権があれば（例: 同じ共有ノートのメンバー）ノートコンテキストで開く。アクセス権がなければ「ページが見つからない」または未解決リンク扱い。 | 実装が単純。元のノートにまだアクセスできる場合は「ノート内のあのページ」に飛べる。 | 自分のページからクリックすると共有ノート側に飛び、文脈が分かりにくい。アクセス権がなくなるとリンクが壊れる。 |
| **B. コピー時に「他ページ参照」をゴーストリンクに変換** | コピー処理の時点で、**同じノート内の他ページを指すリンク**（および、自分が所有者でないページを指すリンク）を **ゴーストリンク** に変換する。リンクテキスト（表示名）は残し、参照先（target_id）は解消しない。 | コピー後のページは「自分のページだけを参照する」か「未解決のリンクテキスト」だけになり、文脈が明確。リンク切れにならない。ユーザーが同名の自分のページを作るか、既存の自分のページにリンクし直せる。 | コピー時にリンク解決情報が失われる。元の「ノート内のあのページ」にワンクリックで飛べなくなる。 |
| **C. 「リンク先のページも一緒にコピー」をオプションで提供** | コピー時に「このページのみ」か「このページと、同じノート内で参照しているページをまとめてコピー」を選べる。まとめてコピーする場合、リンク先ページも自分のページとして新規作成し、本文内のリンクを新しい page_id に付け替える。 | ノート内の一部を「自分のページのサブセット」として一括で持てる。コピー後もリンクがそのまま機能する。 | 実装が重い。コピー範囲（1 階層だけか、再帰的にか）の設計が必要。ノートが大きいとコピー量が増える。 |

#### 推奨

- **基本方針:** **B. コピー時に他ページ参照をゴーストリンクに変換** を推奨する。
  - 理由: 「自分のページ」は自分が所有者のページだけを参照する、という境界を保てる。共有ノートからコピーした結果、クリックすると他人のノートに飛ぶ挙動を避けられ、リンク切れも起きない。ユーザーは必要に応じて同名のページを自分で作るか、既存の自分のページにリンクし直せばよい。
- **拡張:**  UX として「ノートのこの部分をまとめて自分のページにしたい」需要が強い場合は、**C** を「リンク先も一緒にコピー（1 階層のみ）」などのオプションとして後から追加するのがよい。

#### 実装上の注意

- コピー元が共有ノート内のページであるとき、本文（Y.Doc）内のリンクを走査し、「target が同じノート内のページ」または「target が自分が owner でないページ」であれば、そのリンクをゴーストリンク（link_text のみ保持、target なし）に置き換えた Y.Doc を新規ページ用に作成する。
- links テーブルは「ページ A → ページ B」の関係を保持する。コピー後の新規ページでは、変換後に残った「自分が所有者のページへのリンク」だけを links に登録し、ゴーストリンクにしたものは ghost_links に登録する。**共有ノート内の他ページを指していたリンク**をゴースト化した場合は、ghost_links 登録時に `original_target_page_id` と `original_note_id` に元の page_id と note_id を設定する（§2.7）。

### 3.4 「リンク先も取得したい」場合の UX：クリック時に選択させる案

§3.3 でゴーストリンクに変換したリンクのうち、**元の参照先が共有ノート内のページだったもの**については、「解釈の選択」をユーザーに委ねる UX が考えられる。

**提案の内容**

- 共有ノートからコピーしたページに含まれるゴーストリンクのうち、**元のリンク先（共有ノート内のページ）が分かっているもの**は、通常のゴーストリンクとは別種のリンクとして表示する（例: 見た目やアイコンで区別、または「未解決（元のノートにあり）」などのラベル）。
- ユーザーがそのリンクをクリックしたとき、次の **2 択** を提示する：
  1. **自分のオリジナルページとして作成** … そのタイトルで、中身のない新規ページを自分のページとして作成し、そこへ遷移する。
  2. **元の共有ノートのページをコピー** … 元のノート内のそのページを「自分のページ」としてコピーし、コピー先のページへ遷移する（コピーしたページ内のリンクは、§3.3 と同様にゴーストリンク化する。その結果できたゴーストリンクにも、元参照先が分かれば同じ「選択 UI」を適用できる）。

以下、この案の良い点・悪い点と、実装上のポイントを整理する。

#### 良い点（メリット）

| 観点 | 説明 |
|------|------|
| **意図の明確化** | クリック時に「新規で自分用に作る」か「共有ノートの内容を持ってくる」かを明示的に選べる。どちらの結果になるかが分かりやすく、勘違いが少ない。 |
| **リンク先の取得を遅延できる** | コピー時にまとめてコピー（§3.3 の C）をしなくても、必要なリンクだけ「クリックしたときにもう一度コピー」で取得できる。必要な分だけ自分のページが増える。 |
| **段階的なコピー** | 「まず 1 ページだけコピー → 気になったリンクをクリックして、そのとき「コピー」を選ぶ」という使い方ができる。ノート全体を一度にコピーする必要がない。 |
| **通常のゴーストリンクとの役割分担** | 手で書いた `[[見出し]]`（参照先不明）は「新規作成」のみでよく、「共有ノート由来のゴースト」だけ選択 UI にすると、挙動の違いが理解しやすい。 |
| **元の文脈を活かせる** | 「元の共有ノートのページをコピー」を選べば、ノート内の内容（本文・構造）をそのまま自分のページとして持てる。 |

#### 悪い点・課題（デメリット）

| 観点 | 説明 |
|------|------|
| **クリックのたびに選択が入る** | リンクをクリックするたびにモーダルやメニューが開く。常に「新規作成」または常に「コピー」でよいユーザーには一手間になる。デフォルトや「今後はこの選択を記憶」などの省略手段があるとよい。 |
| **元参照先の情報の保持** | 「元の共有ノートのページをコピー」を実現するには、ゴーストリンクに **元の target（page_id）および属する note_id** が紐づいている必要がある。→ **対応済み:** ghost_links に `original_target_page_id`, `original_note_id`（NULL 許容）を追加するスキーマ拡張を採用（§2.7）。 |
| **アクセス権の変動** | クリック時点で、そのノートへのアクセスが取り消されている可能性がある。その場合は「コピー」を選べないようにするか、「このノートへのアクセスがありません」と表示する必要がある。表示のたびに API でアクセス可否を確認するか、キャッシュと組み合わせる設計がいる。 |
| **UI の配置** | 選択 UI をモーダル・ドロップダウン・コンテキストメニューのどれにするか、また「リンクとしての見た目」と「クリック後の選択」の関係をどう説明するかで、実装とテストが増える。 |
| **同一タイトルが複数ある場合** | ノート内に同じタイトルのページが複数あると、「元のページ」が一意に定まらない。元参照先を page_id で持てば一意だが、link_text だけだと曖昧になる。 |

#### 実装上のポイント

- **元参照先の保存（スキーマ拡張を採用）**
  - **ghost_links テーブルを拡張**し、`original_target_page_id` と `original_note_id`（いずれも UUID NULL）を追加する（§2.7 で定義済み）。共有ノートからコピーしたページ内のリンクをゴースト化した場合だけ、これらに元の page_id と note_id を設定する。通常のゴースト（手書きの未解決リンク）は両方 NULL のまま。
  - クリック時に「コピー」を選んだ場合は、この 2 カラムから元のノート・ページを特定し、API でそのページを取得してコピー処理を実行する。

- **選択の省略**
  - 「同じセッション内では前回の選択をデフォルトにする」「設定で「常に新規作成」「常にコピー」を選べる」などにすると、繰り返しクリックする場合の手間を減らせる。

- **「コピー」選択時の挙動**
  - 元の共有ノートのページをコピーするときも、§3.3 と同様に「同じノート内の他ページへのリンク」はゴーストリンクに変換する。そのゴーストに元参照先が付いていれば、同じ「新規作成 or コピー」の選択 UI を再帰的に使える。

この案は、**ゴーストリンクに変換しつつ、リンク先の内容を必要なときだけ取得できる** バランスの良い拡張である。ghost_links のスキーマ拡張（§2.7）により元参照先を保持する方針で確定している。

---

## 4. ローカルストアと同期・リアルタイムの設計

### 4.1 ローカルに保存するものは「自分のページ」のみ

**方針:** ローカルに保存するのは **自分が所有者のページ（自分のページ）** だけとする。共有されているノートやその中のページはローカルに保存せず、ノート用画面（例: `/notes/[id]`）で表示するときに API から都度取得する。

| データ | ローカルに保存 | 表示・取得方法 |
|--------|----------------|----------------|
| **自分のページ**（メタデータ） | ✅ 保存する | 一覧は **ローカル** から即表示。表示速度を最優先する。 |
| **自分のページ**（本文 Y.Doc） | ✅ 保存する | 開いたページは **ローカル** の Y.Doc から即表示。自分のページにリアルタイム性は不要。 |
| **ノート一覧**（自分がオーナー／メンバーのノート） | ❌ 保存しない | ノート一覧画面では **API** から取得。 |
| **共有ノートの中身**（ノートに含まれるページ） | ❌ 保存しない | `/notes/[id]` で **API** から取得。必要ならリアルタイム編集時に Hocuspocus で同期。 |

クラウド（Aurora）には従来どおり users, pages, notes, note_pages, note_members, links, ghost_links の全体を保持する。

### 4.2 データの二層構造（自分のページまわり）

| 層 | 内容 | 保存場所（クラウド） | 保存場所（ローカル） |
|----|------|----------------------|------------------------|
| **メタデータ（自分のページのみ）** | pages（owner_id = 自分）, links（自ページ同士）, ghost_links（自ページ） | Aurora に全体あり | ローカル DB（自分のページ分だけ。IndexedDB 直接 or 最小スキーマの SQLite 等） |
| **ページ本文（自分のページのみ）** | 1 ページ = 1 Y.Doc。API で保存／取得可能にしておく | Aurora の page_contents（ydoc_state）等 | IndexedDB（y-indexeddb）、documentId = page_id |

ローカル DB には **notes / note_pages / note_members は持たない**。ノート一覧・共有ノートの表示はすべて API に依存する。

### 4.3 表示速度の優先（自分のページ）

- **自分のページ一覧:** アプリ起動時にローカルから読み、**同期を待たずに一覧を表示**する。オンライン時はバックグラウンドで API と差分同期し、必要なら一覧を更新する。
- **自分のページを開く:** ローカルに Y.Doc があれば **即表示**。自分のページについてはリアルタイム編集は不要なので、Hocuspocus に接続せず、保存は「編集の確定時や一定間隔で API に送る」形でよい。
- ローカルストアは「自分のページ」用の最小構成（ページメタデータ + 必要なら links/ghost_links）にし、IndexedDB を直接使うなど **初期化が軽い方式** にすると、起動〜一覧表示までの体感速度を上げやすい。

### 4.4 共有ノートとリアルタイム編集

- **共有ノートの表示:** ノート用画面（例: `/notes/[id]`）を開いたとき、そのノートのメタデータと含まれるページ一覧・本文は **API** で取得する。ローカルには保存しない。
- **共有ノート内のページのリアルタイム編集:** 複数人で同時編集する必要があるのは共有ノート内のページなので、**そのページを開いているときだけ** Hocuspocus に接続する（ルーム名 = page_id）。アクセス制御は「そのページを含むノートのメンバーで編集権限があるユーザー」に限定する。
- 自分のページは単独利用が前提のため、**Hocuspocus は共有ノート用**とし、自分のページでは使わない設計でよい。

### 4.5 同期の流れ（イメージ）

1. **自分のページのメタデータ**
   - 起動時: ローカルから一覧を即表示。
   - オンライン時: API で「自分の pages」を差分取得（例: last_sync 以降）し、ローカルを更新。オフラインで行った変更はキューに積み、復帰時に API に送る。
2. **自分のページの本文（Y.Doc）**
   - 開く: ローカルに Y.Doc があればそれで即表示。なければ API で ydoc_state を取得してローカルに保存してから表示。
   - 保存: 編集の確定時や一定間隔で API に ydoc_state を送る（リアルタイム同期は行わない）。
3. **ノート一覧・共有ノート**
   - ノート一覧: 表示時に API で「自分がアクセスできる notes」を取得。
   - `/notes/[id]`: 表示時に API でそのノートと note_pages、必要ならページ本文を取得。編集時は Hocuspocus でリアルタイム同期。

---

## 5. 永続化まわり（サーバー側）のオプション

- **page_contents テーブル（案）**
  - page_id UUID, ydoc_state BYTEA, version BIGINT, updated_at TIMESTAMPTZ
  - Hocuspocus が Y.Doc のスナップショットをここに書き、再接続・新タスク起動時に読み込む。
- 全文検索が必要な場合は、Y.Doc から抽出した content_text を pages または page_contents に持たせ、PostgreSQL の全文検索インデックスを張る。

---

## 6. 現行スキーマとの対応（移行時の参照用）

| 現行 (Turso) | 新設計 (Aurora) |
|--------------|-----------------|
| pages.id (TEXT) | pages.id (UUID) |
| pages.user_id | pages.owner_id (users.id UUID) |
| （なし） | pages.source_page_id（コピー元） |
| pages.content | 本文は Y.Doc。pages には content_preview 等のみ |
| notes.id (TEXT) | notes.id (UUID) |
| notes.owner_user_id | notes.owner_id (users.id UUID) |
| note_pages.note_id, page_id | 同様。UUID に。 |
| note_members.note_id, member_email | 同様。UUID に。 |
| links.source_id, target_id | 同様。UUID に。 |
| ghost_links.link_text, source_page_id, created_at | 同様。source_page_id を UUID に。 |
| （なし） | ghost_links.original_target_page_id, original_note_id（UUID NULL）。共有ノート由来のゴースト用。§3.4 参照。 |

---

## 7. 今後の検討事項（仕様確定前に詳細を詰めるもの）

各項目の選択肢・メリット・デメリット・UX 観点での推奨は **docs/specs/zedi-future-considerations-options.md** にまとめてある。

- **メタデータのローカルストア:** ローカルに保存するのは自分のページのみと確定。そのうえで、IndexedDB を直接使うか（表示速度優先）、SQLite WASM を最小スキーマで使うかを選ぶ。
- **メタデータ同期 API:** 差分同期（last_updated_at ベース）にするか、ページ単位でイベントを送るか。
- **オフライン時の作成・更新:** 競合解決方針（Last-Write-Wins か、サーバーでマージするか）。
- **Hocuspocus の永続化タイミング:** 一定間隔 / 接続切断時 / 両方 等。
- **users の作成タイミング:** 初回サインイン時のみか、毎回 upsert か。
- **member_email と users:** 招待はメールのままにして、アクセス時に「現在のユーザーの email が note_members.member_email に一致」で見るか、note_members に user_id を追加して「招待承諾時に user_id を埋める」か。

---

## 8. 関連ドキュメント

| ドキュメント | 用途 |
|-------------|------|
| docs/specs/realtime-collaboration-specification.md | リアルタイム編集・Y.Doc・Hocuspocus の全体像 |
| docs/plans/20260208/turso-to-aurora-migration-decisions.md | Turso → Aurora 移行で決まっていること・未決定事項 |
| docs/plans/20260208/phase-c-work-breakdown.md | Phase C（DB 移行・永続化）の位置づけ |
| src/lib/turso.ts | 現行スキーマ・同期ロジック |

---

**以上、新 Zedi のデータ構造と「ローカル保持・クラウド同期なしでも表示・リアルタイム編集」を両立させるための仕様案である。フィードバックに応じて項目の追加・修正を行う。**
