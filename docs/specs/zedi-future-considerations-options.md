# 今後の検討事項：選択肢と UX 観点

**作成日:** 2026-02-08  
**最終更新:** 2026-02-09（現行実装調査を踏まえ §7〜§11 を追加、§12 まとめを更新）  
**前提:** `docs/specs/zedi-data-structure-spec.md` §7 の各項目について、実装の選択肢・メリット・デメリット・ユーザー体験への影響を整理する。

---

## 1. メタデータのローカルストア

**前提（仕様で確定）:** ローカルに保存するのは **自分のページのみ**。共有ノート・ノートに含まれるページはローカルに保存せず、ノート一覧は API 取得、共有ノートの中身は `/notes/[id]` で API 取得する。自分のページ一覧は **表示速度を最優先** し、リアルタイム性は不要。

**論点:** 自分のページのメタデータ（と、必要なら links / ghost_links）をローカルに持つとき、**SQLite WASM を継続するか**、**IndexedDB を直接使うか**（その他は現状スコープ外とする）。

**現行実装:** `sql.js`（SQLite WASM）を使用し、IndexedDB に永続化（`idb-keyval`）。全テーブル（pages, notes, note_pages, note_members, links, ghost_links）をローカルに保持。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. SQLite WASM（自分のページ用の最小スキーマ）** | IndexedDB 上に SQLite を置くが、ローカルに持つのは **pages（自分の分のみ）** と **links / ghost_links**（自ページに関係するもののみ）。notes / note_pages / note_members は持たない。 |
| **B. IndexedDB 直接（自分のページ用）** | IndexedDB にオブジェクトストアを 1 つ（例: `my_pages`）用意し、キー = page_id、値 = ページメタデータの JSON。一覧用に `updated_at` 等のインデックスを張る。links / ghost_links も別ストアで同様。WASM は使わない。 |
| **C. ローカルファースト用ライブラリ** | RxDB 等を導入し、そのストアに「自分のページ」だけを同期する。 |

### 比較

| 観点 | A. SQLite WASM（最小スキーマ） | B. IndexedDB 直接 | C. ローカルファースト用ライブラリ |
|------|-------------------------------|--------------------|----------------------------------|
| **表示速度（初回描画）** | WASM の読み込み・初期化が入るため、一覧表示までに数百 ms〜数秒かかることがある | ネイティブ IndexedDB のみで、初期化が不要。起動後すぐに getAll + インデックスで一覧取得可能で **速い** | ライブラリの初期化次第 |
| **データ量** | 自分のページ＋関連 links/ghost_links だけなので、どちらも十分軽い | 同左。JSON でも件数が多くなければ問題になりにくい |
| **移行コスト** | 現行の sql.js を「自分のページだけ」に絞って流用可能。中程度 | 新規に「自分のページ」用の読み書きを実装。中程度 | 高（ライブラリの組み込み・同期方針の合わせ込み） |
| **クエリ** | SQL で「updated_at 順」等が書きやすい | インデックスで範囲取得。シンプルな一覧なら十分 |
| **デバッグ** | SQL で中身を確認しやすい | DevTools の IndexedDB で確認可能 |
| **Y.Doc との共存** | sql.js と y-indexeddb が別々に IndexedDB を使う形。管理が 2 系統 | メタデータ用 IndexedDB と y-indexeddb（Y.Doc 用）の 2 ストアで統一的 |

### UX への影響

- **「開いてすぐ自分のページ一覧が出る」** ことを最優先するなら、WASM の初期化を挟まない **B. IndexedDB 直接** の方が有利。アプリ起動→一覧表示までの体感が短くなる。
- A を選ぶ場合は、WASM の遅延読み込みや「一覧用のデータだけ先に IndexedDB にキャッシュしておく」などの工夫で表示速度を補う必要がある。
- Y.Doc もローカルに保存する設計（§7 参照）のため、いずれにしても IndexedDB は使う。**B** にするとメタデータ・Y.Doc ともに IndexedDB で管理でき、依存ライブラリが減る。

### 推奨（表示速度優先・自分のページのみローカル）

- **B. IndexedDB 直接（自分のページ用の最小ストア）** を推奨。自分のページのメタデータと、必要なら links / ghost_links を IndexedDB のオブジェクトストアで保持し、一覧はインデックスでソートして表示する。WASM を挟まない分、起動〜一覧表示が速く、仕様（自分のページのみローカル・表示速度優先）と一致する。
- 現行の Turso/同期ロジックをなるべく変えたくない場合は **A** でもよいが、その場合は「WASM 初期化を非同期にして、準備できるまで一覧をスケルトン表示にする」など、待ち時間を UX でカバーすることを推奨する。

---

## 2. メタデータ同期 API

**前提:** ローカルと同期するメタデータは **自分のページのみ**。ノート一覧・共有ノートは API 都度取得のため、この「同期 API」の対象外。

**論点:** 自分のページのメタデータをクラウド（Aurora）とローカルで揃えるとき、**差分同期（last_updated_at ベース）** にするか、**イベント配信** にするか。自分のページにはリアルタイム性は不要なので、一覧の「できるだけ速く表示」が優先。

**現行実装:** Turso へのデルタ同期（`lastSyncTime` ベース）。初回ロードまたは手動トリガーで同期。バックグラウンド自動同期は未実装。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 差分同期（タイムスタンプベース）** | クライアントが「最後に同期した時刻」を送り、サーバーは updated_at > last_sync のレコードだけ返す。クライアントはそれでローカルをマージ。 |
| **B. イベント/変更ストリーム** | サーバーが「このページが更新された」「このノートにページが追加された」等のイベントをストリーム（WebSocket/SSE）またはポーリングで配信。クライアントはイベントに応じて該当レコードを取得・マージ。 |
| **C. ハイブリッド** | 初回・長時間オフライン後は「全件または大きな差分」を取得し、通常時は B のイベントで増分だけ反映。 |

### 比較

| 観点 | A. 差分同期 | B. イベント | C. ハイブリッド |
|------|-------------|-------------|-----------------|
| **実装の単純さ** | 高い（1 リクエストで差分取得） | 中（イベント配送・重複除去が必要） | 中〜高 |
| **リアルタイム性** | 低（ポーリング間隔に依存） | 高（イベント即配信） | 高 |
| **オフライン復帰時** | 1 回の差分で一括取得しやすい | イベント履歴の保持・再送が必要 | 初回は差分、以降はイベントで良い |
| **サーバー負荷** | ポーリング多めだと負荷増 | 接続維持とイベント配送の負荷 | 両方の良いとこ取りだが実装は重い |
| **競合** | 同じ last_sync から複数クライアントが取ると同じ差分を何度も取る可能性 | イベント順序の保証が必要 | 同様 |
| **現行実装からの距離** | **近い**（現行のデルタ同期を API に置き換えるだけ） | 遠い（WebSocket/SSE の仕組みが必要） | 中 |

### UX への影響

- **「他デバイスで変更したら、このデバイスでも早く反映したい」** なら **B または C** が有利。編集後、別タブや別端末で開いたときに「しばらく待つと出てくる」ではなく「数秒で一覧が更新される」体感になる。
- **「オフラインでたくさん編集して復帰したとき、一気に反映したい」** なら **A** が扱いやすい。1 回の差分取得で済む。
- **「一覧を開いたときに毎回少し待つ」** のを避けたいなら、B/C で「バックグラウンドでイベント反映」にすると、ユーザーが明示的に「同期」を押さなくても一覧が更新される。

### 推奨（自分のページのみ同期・表示速度優先）

- **A. 差分同期** で十分。自分のページ一覧はローカルから即表示し、バックグラウンドで `?since=last_sync` の差分取得を行う。リアルタイム性は不要なので、イベント配信（B/C）は不要。オフライン復帰時も 1 回の差分で一括取得すればよい。
- 現行のデルタ同期ロジックを「Turso 直結」から「API 経由」に差し替える形で移行でき、実装コストも低い。

---

## 3. オフライン時の作成・更新の競合解決

**論点:** オフライン中に同じリソース（例: 同じページのタイトル、同じノートのメンバー）を複数デバイスで変更した場合、**Last-Write-Wins（LWW）** にするか、**サーバーでマージ** するか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. Last-Write-Wins（LWW）** | サーバーに届いた「最後の更新」で上書きする。updated_at または送信時刻で比較。 |
| **B. サーバーでマージ** | フィールド単位で「両方の変更を反映する」ロジックを書く（例: タイトルは LWW、メンバー一覧はマージ）。 |
| **C. 競合を検出してユーザーに選ばせる** | 競合時に「あなたの変更」と「クラウドの変更」を並べて、ユーザーがどちらを残すか選ぶ（または手動マージ）。 |

### 比較

| 観点 | A. LWW | B. サーバーでマージ | C. ユーザーに選ばせる |
|------|--------|---------------------|------------------------|
| **実装コスト** | 低 | 高（リソースごとのルール設計） | 中（UI と競合検出） |
| **データ損失** | あり（後から送った方が勝つため、先に送った変更が消える） | なるべく減らせる | ユーザーが選ぶので「意図しない上書き」は減る |
| **予測可能性** | 高い（「最後に送ったのが残る」と説明しやすい） | 中（ルールが複雑だとユーザーが理解しづらい） | 中（選ぶ手間はあるが結果は明確） |
| **ページ本文** | 本文は Y.Doc（CRDT）なので別扱い。メタデータのみの話。 | 同左 | 同左 |

### UX への影響

- **メタデータ**（タイトル・ノート名・メンバー追加等）は、複数人が同時に編集する頻度はページ本文より低い。そのため **A. LWW** でも、多くの利用では「片方の変更が消える」事象は起きにくい。
- **「編集が消えた」** と感じると信頼を損なうので、**B** で可能な範囲でマージするか、**C** で「競合しました」と通知して選ばせると安心感は高い。その代わり、**C** は「オフラインから復帰するたびに選ぶ画面が出る」と煩わしくなるリスクがある。
- **ページ本文** は Y.Doc で CRDT マージされるため、ここでいう「競合」は主に **メタデータ** に限定して考えてよい。

### 推奨（UX を優先する場合）

- **基本方針:** **A. LWW** で開始し、updated_at（サーバー時刻で正規化）で「最後に更新されたもの」を採用。実装が簡単で、説明も「最後に保存した内容が残ります」で済む。
- **強化する場合:** 重要なフィールド（例: ノートのメンバー一覧）だけ **B** のマージを入れる（「追加」は両方取り、削除は LWW 等）。あるいは、競合が検出されたときだけ「片方の変更が上書きされました」とトーストで知らせ、**C** ほど重くしない形でフィードバックする。

---

## 4. Hocuspocus の永続化タイミング

**論点:** ページ本文（Y.Doc）をサーバー側（Aurora 等）に保存するタイミングを **一定間隔** にするか、**接続切断時** にするか、**両方** にするか。

**現行実装:** Hocuspocus サーバーは ECS Fargate にデプロイ済みだが、**メモリのみ（永続化なし）**。Redis / Aurora への保存は未実装。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 一定間隔（例: 30 秒ごと）** | タイマーで定期的に ydoc_state を DB に書き込む。 |
| **B. 接続切断時のみ** | クライアントがルームを抜けたとき、または接続が切れたときに 1 回保存。 |
| **C. 両方** | 定期的に保存しつつ、切断時にも保存する。 |
| **D. 変更があったときのみ（デバウンス）** |  Y.Doc に更新があったら N 秒後に 1 回保存する（デバウンス）。 |

### 比較

| 観点 | A. 一定間隔 | B. 切断時のみ | C. 両方 | D. デバウンス |
|------|-------------|---------------|---------|----------------|
| **データ損失リスク** | 低（最後の N 秒は失う可能性） | 高（サーバー落ち・強制終了で保存されない） | 低 | 低（無編集なら書かない） |
| **書き込み回数** | 多い（全ルームを N 秒ごと） | 少ない | 多い | 編集があったルームだけ |
| **復帰時の鮮度** | 数秒〜数十秒前の状態から復元 | 最後に誰かが切断した時点 | A と B の良いとこ | 編集が止まってから N 秒後 |
| **実装** | 簡単 | 簡単（onDisconnect 等） | 簡単だが両方のパスを維持 | やや複雑（デバウンス・未保存フラグ） |

### UX への影響

- **「サーバーが落ちた／タブを閉じた直後にクラッシュ」** で編集が消えると UX が悪い。**B のみ** は、サーバー障害や強制終了で保存されないケースが多く、おすすめしにくい。
- **「別デバイスで開いたときに、さっき編集した内容が出てほしい」** なら、**A または C** で定期的に書いておくと、最後のセーブから数十秒以内の状態が別端末で見られる。
- **「編集していないページまで何度も保存したくない」** なら **D** が効率的。ただし、実装と「未保存のままサーバーが落ちた」のトレードオフを考える必要がある。

### 推奨（UX を優先する場合）

- **C. 両方** を推奨。
  - **定期:** 例として 30〜60 秒ごとに、アクティブなルームの ydoc_state を保存。サーバー障害やクラッシュでも、直近の状態が残る。
  - **切断時:** ルームから全員抜けたとき、または接続切断時に 1 回保存。負荷を抑えつつ「最後の状態」を確実に残す。
- 負荷が気になる場合は、**A** の間隔を長くする（例: 2 分）か、**D** を併用して「編集があったルームだけ定期保存」にするとよい。

---

## 5. users の作成タイミング

**論点:** アプリ内の **users** テーブルにレコードを作るタイミングを **初回サインイン時のみ** にするか、**毎回サインイン時に upsert** するか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 初回サインイン時のみ** | Cognito で初めてサインインしたときだけ users に INSERT。以降は同じ cognito_sub なら作成しない。 |
| **B. 毎回 upsert** | サインインのたびに、cognito_sub をキーに INSERT ... ON CONFLICT DO UPDATE で display_name / email / avatar_url 等を更新。 |

### 比較

| 観点 | A. 初回のみ | B. 毎回 upsert |
|------|-------------|-----------------|
| **プロファイル更新** | Cognito や Google で名前・アイコンを変えても、アプリ側は古いまま | 毎回最新の表示名・アイコンに更新される |
| **API 呼び出し** | 初回だけ users 作成 API を叩けばよい | 毎回サインインで 1 回 upsert（軽い） |
| **他ユーザー表示** | ノートメンバー等で「誰が編集したか」を見るとき、古い表示名のままの可能性 | 常に最新の表示名・アバターで表示できる |

### UX への影響

- **「ノートの共同編集で、相手の名前・アイコンが古いまま」** だと違和感がある。**B** にすると、相手がプロファイルを更新すれば、次回サインイン以降は正しく表示される。
- **「自分が名前を変えたのに、共有ノートで古い名前のまま表示される」** も **B** で解消しやすい。
- 負荷は「サインインごと 1 回の upsert」程度なので、UX のメリットの方が大きい。

### 推奨（UX を優先する場合）

- **B. 毎回 upsert** を推奨。サインイン（またはトークン取得）時に、Cognito の id_token 等から email / name 等を取得し、users を upsert する。共同編集・共有ノートでの「誰が編集したか」の表示が常に現状に近づく。

---

## 6. member_email と users（招待の識別子）

**論点:** ノートの招待を **メールのまま**（note_members.member_email のみ）にして「現在のユーザーの email が一致すればメンバー」とするか、**user_id を追加**して「招待承諾時に user_id を埋める」か。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. メールのみ** | note_members は (note_id, member_email, role, ...) のまま。アクセス時は「現在ログイン中のユーザーの email が member_email に一致するか」でメンバー判定。 |
| **B. user_id を追加（任意で埋める）** | note_members に invited_user_id (NULL 許容) を追加。招待されたユーザーがサインインしてノートを開いたときに、「この email のメンバー行の invited_user_id を自分の user_id で更新」する。メンバー判定は「member_email が一致 OR invited_user_id が自分」。 |
| **C. 招待を「承諾」フローにする** | 招待時に「未承諾」のメンバー行を作り、ユーザーが「承諾」した時点で user_id を埋める。承諾していないとノート一覧に表示しない、または「招待されています」とだけ表示。 |

### 比較

| 観点 | A. メールのみ | B. user_id 追加（任意） | C. 承諾フロー |
|------|----------------|--------------------------|----------------|
| **実装** | 簡単（現行に近い） | 中（初回アクセス時に user_id を埋める処理） | 高（承諾 UI・状態の管理） |
| **メール変更時** | ユーザーが Cognito のメールを変えると、同じ人でも「別メンバー」と見なされ、アクセスできなくなる | user_id を埋めておけば、メールが変わっても user_id で一意に識別できる | 同左 |
| **「誰がこのノートにいるか」** | メールしか分からない。users と突き合わせれば表示名は出せる | user_id があれば users と JOIN で表示名・アバターを安定して表示できる | 同左 |
| **招待の意図** | 「このメールアドレスに招待を送った」で完結 | 「このメールに送ったが、誰が承諾したか」を user_id で追える | 「承諾した人だけがメンバー」と明確になる |

### UX への影響

- **メールを変更したユーザー**（結婚等でメール変更）が、昔招待されたノートにアクセスできなくなるのは **A** の弱点。**B または C** なら、一度 user_id が紐づけばメール変更の影響を受けない。
- **ノート一覧で「共同編集者」を表示する** とき、**B/C** で user_id を持っておくと、users から表示名・アバターを取れるので、「メールだけ表示」より分かりやすい。
- **C** は「招待を受け取った人が承諾するまでノートに入れない」というポリシーにしたい場合に有効。UX は「承諾」ステップが増える代わりに、意図が明確になる。

### 推奨（UX を優先する場合）

- **第一段階:** **A. メールのみ** で開始してよい。現行と同様で実装が早く、多くの利用ではメール変更も起きにくい。
- **強化する場合:** **B. user_id を追加** し、メンバーがノート（またはアプリ）に初めてアクセスしたときに「この member_email は自分」と分かれば、その行の invited_user_id を自分の user_id で更新する。これでメール変更に強くしつつ、共同編集者を users と紐づけて表示できる。承諾の明示が不要なら C まで進まなくてよい。

---

## 7. ページ本文の統一形式（Y.Doc への移行）

**前提（仕様で確定）:** `zedi-data-structure-spec.md` §2.2 で「本文は Y.Doc（CRDT）で保持する。pages テーブルには本文を格納しない」と確定。

**現行実装:** ページ本文は **Tiptap JSON** として sql.js の `pages.content` カラムに保存されている。Y.js パッケージ（`yjs`, `@hocuspocus/provider`, `y-indexeddb` 等）はインストール済みで、`CollaborationManager` と `useCollaboration` フックが共有ノートのリアルタイム編集用に実装されているが、個人ページには適用されていない。

**論点:** 全ページの本文を Y.Doc に統一するか、個人ページは Tiptap JSON を維持するか。Y.Doc に統一する場合、個人ページの扱い方。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 全ページ Y.Doc に統一** | 個人ページ・共有ノートページともに Y.Doc で本文を管理する。個人ページでは Hocuspocus に接続せず、Y.Doc をローカル（IndexedDB）と API（Aurora）で同期する。 |
| **B. 共有ノートのみ Y.Doc、個人ページは Tiptap JSON 維持** | 共有ノートのページは Y.Doc + Hocuspocus。個人ページは従来どおり Tiptap JSON を保存し、必要なら API で Aurora にも JSON を送る。 |
| **C. 全ページ Y.Doc だが、個人ページは Hocuspocus 経由** | 全ページ Y.Doc にし、個人ページでも Hocuspocus にサーバー保存を任せる（ただし他ユーザーとの共有は行わない）。 |

### 比較

| 観点 | A. 全ページ Y.Doc（Hocuspocus は共有のみ） | B. 共有のみ Y.Doc | C. 全ページ Y.Doc（Hocuspocus 全ページ） |
|------|--------------------------------------------|--------------------|------------------------------------------|
| **一貫性** | 全ページ同一形式で、「個人ページを共有ノートに追加」するときも形式変換が不要 | 個人 → 共有に追加するとき、Tiptap JSON → Y.Doc の変換が必要 | A と同じ |
| **エディタ実装** | 同じ Tiptap + Collaboration 構成。Provider の有無で切り替え | 個人用（Tiptap 通常）と共有用（Tiptap + Collaboration）で構成が分かれる | A と同じ |
| **オフライン** | 個人ページは Y.Doc がローカルに常にあるので即表示可能 | 個人ページは JSON がローカルにあるので即表示可能 | Hocuspocus 経由なので、オフライン時にサーバー保存ができない |
| **サーバー負荷** | 個人ページは API でスナップショット保存のみ。Hocuspocus の負荷は共有ページ分のみ | 同左 | 全ページが Hocuspocus に接続するため負荷が高い |
| **実装コスト** | 中（個人ページ用の Y.Doc ローカル保存＋API 同期を実装） | 低（現行の JSON 保存を維持しつつ、共有のみ Y.Doc） | 低（Hocuspocus に全部任せる）だが負荷設計が大変 |
| **移行の複雑さ** | 既存 JSON → Y.Doc 変換が全ページ必要 | 共有ノートのページのみ変換 | 同 A |

### UX への影響

- **A** は「個人ページを後から共有ノートに追加」するとき、本文の形式変換が不要。同じ Y.Doc をそのまま Hocuspocus に接続するだけで共有編集ができる。ユーザーにとって「ページを共有する」操作がシームレスになる。
- **B** は「ページを共有したい」とき、裏で Tiptap JSON → Y.Doc の変換が走る。通常は透過的に行えるが、変換でレイアウトやカスタムノードが壊れるリスクがある。
- **C** は全ページで Hocuspocus に接続するため、個人ページの編集時にもネットワーク遅延やサーバー障害の影響を受ける。「自分だけのページなのに、なぜオフラインだと保存できないの？」という UX の矛盾が生じる。

### 推奨

- **A. 全ページ Y.Doc に統一（Hocuspocus は共有ノートのみ）** を推奨。
  - 理由 1: 本文形式が統一され、「個人ページ↔共有ノート」間の移動が自然になる。
  - 理由 2: 現行の `CollaborationManager` と `useCollaboration` を拡張すれば、個人ページでも「Y.Doc + IndexedDB のみ（Provider なし）」として動作させることは比較的容易。
  - 理由 3: 既存の Tiptap JSON → Y.Doc 変換は `y-prosemirror` の `prosemirrorJSONToYDoc()` で実行可能（`realtime-collaboration-specification.md` §7.2 に例あり）。
  - 個人ページの Y.Doc 同期方式は §8 で詳述する。

---

## 8. 個人ページの Y.Doc 保存・同期方式

**前提（仕様で確定）:** 個人ページでは Hocuspocus を使わない。Y.Doc をローカル（IndexedDB / y-indexeddb）に保存し、クラウド（Aurora）にも API で同期する。

**現行実装:** 共有ページは `CollaborationManager` で `HocuspocusProvider` + `y-indexeddb` を使用。個人ページにはこの仕組みが適用されていない。

**論点:** Hocuspocus に接続しない個人ページの Y.Doc を、どのようにクラウド（Aurora / page_contents テーブル）と同期するか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. スナップショット同期（全体 PUT/GET）** | 保存時に `Y.encodeStateAsUpdate(ydoc)` で Y.Doc 全体をバイナリ化し、API に PUT。読み込み時は GET でバイナリを取得し、ローカル Y.Doc に apply。 |
| **B. 差分同期（Update ベース）** | クライアントが前回同期時の StateVector を保持。同期時に「前回からの差分 update」を計算してサーバーに送り、サーバーからも差分を受け取る。 |
| **C. スナップショット + バージョン管理** | A と同様にスナップショットを保存するが、`ydoc_version`（単調増加のバージョン番号）を付与。クライアントはバージョンを比較し、新しい方を採用。古いバージョンの変更は Y.Doc merge で取り込む。 |

### 比較

| 観点 | A. スナップショット | B. 差分同期 | C. スナップショット + バージョン |
|------|---------------------|-------------|----------------------------------|
| **実装の単純さ** | **高い**（PUT/GET のみ） | 低い（StateVector の管理、差分計算、マージ） | 中 |
| **通信量** | 毎回 Y.Doc 全体（ドキュメントサイズ分） | 差分のみ（小さい） | 毎回全体 |
| **競合時の安全性** | 複数デバイスで編集した場合、後から PUT した方が上書き（LWW） | 差分を CRDT でマージするため、両方の変更が保たれる | バージョン比較＋ Y.Doc merge で両方の変更を取り込める |
| **オフライン復帰** | 1 回の PUT で済む。ただし他デバイスの変更は上書きされるリスク | 差分交換で安全にマージ | バージョンチェック後、必要なら Y.Doc merge |
| **サーバー側の複雑さ** | page_contents に BYTEA で保存するだけ | サーバーにも Y.Doc インスタンスが必要（差分適用のため） | BYTEA + version で保存。マージはクライアント側 |

### UX への影響

- **個人ページは基本的に 1 ユーザーが使う** ため、「複数デバイスで同じページを同時編集」するケースは少ない。多いのは「PC で編集→モバイルで確認」のような逐次アクセス。
- **A** で十分なケースが大半だが、「PC でオフライン編集中にモバイルでも編集してしまった」場合に片方が消える（LWW）リスクがある。
- **C** は A と同程度にシンプルだが、バージョン比較で「ローカルとサーバーの両方に変更がある」ことを検出し、Y.Doc の merge（`Y.applyUpdate(localDoc, remoteSnapshot)` で CRDT マージ）を行えば安全。

### 推奨

- **C. スナップショット + バージョン管理** を推奨。
  - **保存時:** `Y.encodeStateAsUpdate(ydoc)` でバイナリ化し、API に `PUT /api/pages/{id}/content` で送信。サーバーは `page_contents(page_id, ydoc_state, version, updated_at)` に保存し、version を +1 して返す。
  - **読み込み時:** `GET /api/pages/{id}/content` でバイナリ + version を取得。ローカルの version と比較し、リモートが新しければ `Y.applyUpdate(localDoc, remoteState)` で CRDT マージ。ローカルが新しければ PUT で送信。
  - **タイミング:** 編集確定時（デバウンス 3〜5 秒）＋アプリ終了時（`beforeunload`）＋バックグラウンドで定期（例: 60 秒）。
  - **利点:** 万一の同時編集でも CRDT マージにより両方の変更が保たれる。スナップショットなのでサーバー側に Y.Doc インスタンスは不要。API は単純な PUT/GET。

---

## 9. エディタアーキテクチャ（個人ページ vs 共有ノートページ）

**前提（仕様で確定）:** 個人ページは Y.Doc + IndexedDB（Hocuspocus なし）。共有ノートページは Y.Doc + Hocuspocus（リアルタイム同期）。

**現行実装:** `TiptapEditor.tsx` が `collaborationConfig`（Y.Doc + Awareness）を受け取り、Tiptap の `Collaboration` / `CollaborationCaret` エクステンションを条件的に有効化する仕組みがある。`useCollaboration` フックが `CollaborationManager` を呼び出す。

**論点:** 個人ページと共有ノートページで、エディタコンポーネントとデータフローをどう設計するか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 統一 Y.Doc エディタ（Provider 切り替え）** | 全ページで Tiptap + `Collaboration` エクステンションを使用。個人ページでは Y.Doc を IndexedDB から読み込み Provider なしで編集。共有ページでは `HocuspocusProvider` を接続。同じエディタコンポーネントを使い回し、フックで provider の有無を制御する。 |
| **B. 個人用・共有用で別エディタ構成** | 個人ページは Tiptap（Collaboration なし）+ 従来の autosave。共有ページは Tiptap + Collaboration + HocuspocusProvider。コンポーネントは共通にするが、拡張構成が異なる 2 パターンを維持。 |

### 比較

| 観点 | A. 統一 Y.Doc エディタ | B. 別構成 |
|------|------------------------|-----------|
| **コードの重複** | 少ない。Y.Doc の初期化方法が異なるだけで、エディタ本体は同一 | エクステンション構成が 2 パターン。保存ロジックも 2 系統（JSON 保存 vs Y.Doc 保存） |
| **形式変換** | 不要（全ページ Y.Doc） | 個人ページを共有に追加するとき JSON → Y.Doc 変換が必要 |
| **バグの発生リスク** | 低い（1 パターンのテストで済む） | 中（2 パターンを維持・テストする負担） |
| **Collaboration エクステンションの挙動** | Provider なしでも Y.Doc を直接バインドすれば動作する（Tiptap v3 でサポート） | 個人ページでは `content` prop で JSON をロードする従来の方法 |
| **移行コスト** | 中（個人ページの保存フローを JSON → Y.Doc に変更）  | 低（現行を維持しつつ共有ページのみ変更） |

### UX への影響

- **A** では、エディタの挙動が全ページで統一される。「個人ページで太字にする」と「共有ページで太字にする」が完全に同じ操作・同じ結果になる。
- **B** では、稀にエクステンション構成の違いによる微妙な差異（例: カスタムノードの挙動差、Undo/Redo の振る舞い）が出る可能性がある。

### 推奨

- **A. 統一 Y.Doc エディタ** を推奨。
  - 現行の `CollaborationManager` を拡張し、`mode: 'local' | 'collaborative'` のようなパラメータを追加。
  - `local` モード: Y.Doc を IndexedDB から読み込み、`y-indexeddb` で永続化。Provider は接続しない。保存は §8 の方式で API に同期。
  - `collaborative` モード: 現行どおり `HocuspocusProvider` を接続し、リアルタイム同期。
  - エディタ側は `ydoc` と `xmlFragment` を受け取る部分は同一。Awareness（カーソル表示）は `collaborative` モードのみ有効。
  - 実装参考: 現行の `useCollaboration.ts` で `isCollaborative` フラグを追加し、false のときは Provider を作らず Y.Doc のみをセットアップする。

### 実装イメージ

```typescript
// CollaborationManager の拡張概要
class CollaborationManager {
  setup(pageId: string, options: {
    mode: 'local' | 'collaborative';
    token?: string;  // collaborative のみ
  }) {
    this.ydoc = new Y.Doc();
    this.indexeddbProvider = new IndexeddbPersistence(pageId, this.ydoc);

    if (options.mode === 'collaborative') {
      this.hocuspocusProvider = new HocuspocusProvider({
        url: HOCUSPOCUS_URL,
        name: `page-${pageId}`,
        document: this.ydoc,
        token: options.token,
      });
    }
    // local モードでは hocuspocusProvider を作らない
  }
}
```

---

## 10. 全文検索の実装方針

**前提:** Y.Doc 化後、ページ本文は pages テーブルに格納されず、クライアントの IndexedDB（y-indexeddb）とサーバーの page_contents（ydoc_state BYTEA）に保持される。検索のためにはテキスト抽出が必要。

**現行実装:** sql.js ローカル DB で `pages.content`（Tiptap JSON）に対して `LIKE` 検索を実行。

**論点:** Y.Doc 化後の全文検索をどう実装するか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. サーバー側 PostgreSQL 全文検索** | Y.Doc をサーバーに保存するとき、テキストを抽出して `pages.content_text` または `page_contents.content_text` に格納。PostgreSQL の `tsvector` で全文検索インデックスを張る。検索は API 経由。 |
| **B. クライアント側検索（ローカル Y.Doc から）** | クライアントが IndexedDB 内の Y.Doc からテキストを抽出し、ローカルで検索。サーバー検索は行わない。 |
| **C. ハイブリッド（ローカル優先 + サーバー補完）** | 個人ページの検索はローカル Y.Doc から即実行。共有ノートの検索は API 経由で PostgreSQL 全文検索。 |

### 比較

| 観点 | A. サーバー全文検索 | B. クライアント検索 | C. ハイブリッド |
|------|---------------------|---------------------|-----------------|
| **検索範囲** | 全ページ（個人 + 共有）を横断検索可能 | 個人ページのみ（共有ノートのページはローカルにないため検索できない） | 個人はローカル、共有は API |
| **検索速度** | API ラウンドトリップあり（数百 ms） | ローカルなので速い（数十 ms） | 個人ページは速い。共有は API |
| **オフライン** | 不可 | 可能（個人ページのみ） | 個人ページは可能 |
| **テキスト抽出タイミング** | Y.Doc 保存時にサーバー側で抽出 | 検索時にクライアント側で抽出 | 両方 |
| **実装コスト** | 中（サーバーに Y.Doc → テキスト抽出ロジックが必要） | 低〜中（クライアントのみ） | 高（両方実装） |
| **日本語対応** | PostgreSQL の `pg_bigm` や `pgroonga` で対応可能 | JavaScript で実装。形態素解析は重い | 同左 |

### UX への影響

- 現行の検索は「全ページ検索」が可能。Y.Doc 化後も **「全ページ横断検索」** のユーザー体験は維持したい。
- **B** だけでは共有ノートのページが検索できないため、ユーザー体験が後退する。
- **C** が理想的だが、実装コストが高い。まずは **A** でサーバー検索を実装し、将来的にローカル検索を追加するのが現実的。

### 推奨

- **まず A. サーバー側 PostgreSQL 全文検索** を実装。
  - page_contents テーブルに `content_text TEXT` カラムを追加。Y.Doc 保存時にテキストを抽出して格納。
  - 日本語検索には `pg_bigm`（2-gram）を推奨。Aurora PostgreSQL でサポートされており、追加インストール不要。
  - 検索 API: `GET /api/search?q=keyword` で pages + page_contents を JOIN してタイトル・本文を横断検索。
  - テキスト抽出: サーバー側で `Y.Doc` を読み込み、`yDocToProsemirrorJSON()` → JSON のテキストノードを連結。または Hocuspocus 保存時にフック内で抽出。
- **将来の強化:** 個人ページのローカル検索（C のローカル部分）を追加し、オフライン検索に対応。

---

## 11. Tiptap JSON → Y.Doc の移行パス

**前提:** 既存の全ページ本文は Tiptap JSON 形式で Turso / sql.js に格納。新アーキテクチャでは Y.Doc で管理。Aurora 移行に合わせてデータ変換が必要。

**現行実装:** `realtime-collaboration-specification.md` §7.2 に `prosemirrorJSONToYDoc()` を用いた変換例が記載済み。

**論点:** 既存ページの Tiptap JSON → Y.Doc 変換をいつ・どのように行うか。

### 選択肢

| 選択肢 | 概要 |
|--------|------|
| **A. 一括バッチ変換（Aurora 移行時）** | Turso → Aurora のデータ移行スクリプトに含めて、全ページの `content`（Tiptap JSON）を Y.Doc バイナリに変換し、`page_contents.ydoc_state` に格納。移行完了後は JSON を参照しない。 |
| **B. オンデマンド変換（初回アクセス時）** | Aurora には JSON のまま移行。ユーザーがページを開いたときに、サーバー（またはクライアント）が JSON → Y.Doc に変換し、以降は Y.Doc として保存。未アクセスのページは JSON のまま残る。 |
| **C. 段階的移行（新規は Y.Doc、既存はオンデマンド）** | 移行後に新規作成されるページは最初から Y.Doc。既存ページは開いたときに B の方式で変換。 |

### 比較

| 観点 | A. 一括バッチ | B. オンデマンド | C. 段階的 |
|------|---------------|-----------------|-----------|
| **移行の確実性** | 全ページが一気に Y.Doc になる。漏れがない | 未アクセスページは JSON のまま。全文検索等で「JSON の分と Y.Doc の分」の 2 系統を扱う必要がある | B と同様 |
| **移行時間** | ページ数に依存（数千ページでも数分程度、`prosemirrorJSONToYDoc` は高速） | 移行時間ゼロ。初回アクセス時に数百 ms 程度 | 移行時間ゼロ |
| **データ整合性** | 移行スクリプトのテストが必要。失敗時のロールバックも考慮 | 個別ページ単位なのでリスクが小さい | 同左 |
| **コードの複雑さ** | 移行後は Y.Doc のみ扱えばよい。シンプル | 「JSON か Y.Doc か」を判定するロジックがクライアント・サーバー双方に必要 | 同左 |
| **全文検索への影響** | 移行時に一括でテキスト抽出 → `content_text` に格納可能 | 未変換ページのテキストは JSON から別途取得する必要がある | 同左 |

### UX への影響

- **A** はユーザーに対して透過的。移行後は全ページが統一形式で動作し、UX 上の差異はない。
- **B/C** は「初回アクセス時に変換が走る」ため、ごく僅かな遅延（数百 ms 以内）が発生するが、ユーザーが気づくレベルではない。ただし、**コードの複雑さが長期的な負債になる**。

### 推奨

- **A. 一括バッチ変換** を推奨。
  - 理由 1: 移行後のコードが「Y.Doc のみ」に統一され、条件分岐が不要。保守性が高い。
  - 理由 2: 全ページのテキスト抽出（全文検索用）も移行時に一括で行える。
  - 理由 3: 変換は `prosemirrorJSONToYDoc()` で機械的に実行可能（realtime-collaboration-specification.md §7.2 に実装例あり）。
  - **移行手順（概要）:**
    1. Turso から全ページの `content` を取得。
    2. 各ページの Tiptap JSON を `prosemirrorJSONToYDoc(schema, content)` で Y.Doc に変換。
    3. `Y.encodeStateAsUpdate(ydoc)` でバイナリ化。
    4. Aurora の `page_contents(page_id, ydoc_state, version=1, updated_at)` に INSERT。
    5. 同時に Y.Doc からテキストを抽出し、`pages.content_preview` / `page_contents.content_text` に格納。
    6. 移行後、`pages.content` カラムは参照しない（将来的に DROP）。
  - **ロールバック:** Turso を読み取り専用で維持しておけば、問題発生時に JSON からの再変換や切り戻しが可能。

---

## 12. まとめ：UX 優先の推奨組み合わせ

**前提:** ローカルに保存するのは自分のページのみ。共有ノートは `/notes/[id]` で API 取得。自分のページは表示速度優先・リアルタイム不要。

| # | 検討事項 | 推奨 | 主な理由（UX・実装） |
|---|----------|------|----------------------|
| 1 | メタデータのローカルストア | **B. IndexedDB 直接** | WASM を挟まないため起動〜一覧表示が速い。Y.Doc 用の IndexedDB と管理を統一できる。 |
| 2 | メタデータ同期 API | **A. 差分同期** | 自分のページのみ同期でよく、リアルタイム不要。現行のデルタ同期を API に差し替えるだけで移行可能。 |
| 3 | オフライン競合解決 | **A. LWW で開始、重要箇所だけ B** | 説明しやすく実装も軽い。メタデータ競合は頻度が低い。本文は Y.Doc CRDT で自動解決。 |
| 4 | Hocuspocus 永続化 | **C. 定期＋切断時** | 障害・クラッシュで編集が消えにくく、別デバイスでも近い状態が読める。 |
| 5 | users の作成タイミング | **B. 毎回 upsert** | 表示名・アバターが常に最新になり、共同編集の「誰が編集したか」が分かりやすい。 |
| 6 | member_email と users | **まず A. メールのみ、のちに B** | 実装を簡素に開始。メール変更や表示名連携は後で強化。 |
| 7 | ページ本文の統一形式 | **A. 全ページ Y.Doc に統一** | 形式統一により個人↔共有の移行がシームレス。エディタの実装も 1 パターンで済む。 |
| 8 | 個人ページの Y.Doc 同期 | **C. スナップショット + バージョン** | API がシンプル（PUT/GET）で、万一の同時編集でも CRDT マージで安全。 |
| 9 | エディタアーキテクチャ | **A. 統一 Y.Doc エディタ** | Provider の有無で切り替えるだけ。コード重複が少なくバグが出にくい。 |
| 10 | 全文検索 | **A. サーバー PostgreSQL（pg_bigm）** | 個人・共有を横断検索可能。将来ローカル検索を追加して強化。 |
| 11 | JSON → Y.Doc 移行 | **A. 一括バッチ変換** | 移行後のコードが Y.Doc のみに統一され保守性が高い。全文検索用テキスト抽出も一括で可能。 |

この組み合わせで進めると、**実装コストを抑えつつ、オフライン・同期・共同編集の UX をバランスよく満たしやすい**。必要に応じて、各項目を「強化オプション」に差し替えていく形にするとよい。

---

## 付録: 現行実装からの移行ステップ（参考）

上記の推奨をすべて採用した場合の、現行実装からの主な変更点を整理する。

| 現行 | 新 | 変更内容 |
|------|-----|----------|
| sql.js（SQLite WASM）でメタデータ管理 | IndexedDB 直接 | `my_pages` / `my_links` / `my_ghost_links` ストアを新設。sql.js + idb-keyval を除去。 |
| Turso に直結同期 | API（Lambda + API Gateway）経由 | `turso.ts` を `apiClient.ts` に差し替え。差分同期は `?since=last_sync` で API 呼び出し。 |
| ページ本文は Tiptap JSON | Y.Doc（全ページ） | Aurora 移行時に一括変換。エディタは全ページ `Collaboration` エクステンション使用。 |
| 個人ページは Collaboration なし | Y.Doc + IndexedDB（Provider なし） | `CollaborationManager` に `local` モード追加。Y.Doc をローカル保存＋ API 同期。 |
| 共有ページは Hocuspocus（メモリのみ） | Hocuspocus + Aurora 永続化 + Redis | `onStoreDocument` で Aurora に保存。Redis で Pub/Sub。定期＋切断時保存。 |
| ローカル SQL で全文検索 | PostgreSQL `pg_bigm` + API | `GET /api/search` で横断検索。テキストは Y.Doc 保存時に抽出。 |
